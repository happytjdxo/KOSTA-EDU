
<9/3 Web>

이클립스는 편집툴이다. 여기서 작성한 코드를 이클립스에서 한거다.
자바라면 jvm에서 돌아가는데 얘는 서버에서 돌아간다.
구동되는건 서버!
jsp파일이 탐켓으로 배.포. 되어야 한다.
실행을하면 이클립스가 내가 한 일을 탐켓 홈으로 배포시켜 실행시킨다.
실행시키면 D:\cmj\webPro\apache-tomcat-7.0.64(여기까지가 tomcat의 홈이다)\webapps 여기서 배포가 된다.
배포 되기전에 어떤 폴더에 들어가 있는데 안보이는 폴더에 들어가 있다.
여기서 서버설정을 다시 한다.

서버 설정을 다시 함으로써
D:\cmj\webPro\apache-tomcat-7.0.64\webapps\Test 이쪽 서버내부에 배포된다.
디렉터리 구조를 잘 알고 있자! 디렉터리 구조를 잘 알고 웹을 만져야 한다!
모르고 만지는건 말이 안된다.
제대로 프로그램 짜는 친구들은 다 잘알고 있다.

--------- 이 위에까지가 서버 설정이였다. --------------

웹프로그래밍에서 클라이언트(브라우저)는 인터넷이 안되면 연결을 못한다.

웹 기반의 Client!이기 때문에 인터넷을 통해서 요청하게 됨.

요청은 www.naver.com -> 엔터 
실제로는 203.247.192.49 이런식으로 서버에 연결된다. 이름을 외우기 힘드니까
네이버로 된 도메인으로 요청을 하는거임.
요청 1에 대한 응답은 응답 1 이 된다.
응답을 하면 홈페이지가 뜬다.
서버 사이트에 요청이 오면 모든 요청을 받는 서버가 있다 그 서버는 httpd라는 데몬 서버(웹서버)이다.
데몬 서버가 받아서 요청을 까본다(Stream). 
http://www.naver.com -> 이게 http://www.naver.com/index.html 이게 뜨는거다 여기서 index.html 는 숨겨져 있는거임

http://www.naver.com/index1.html 을 하면 오류 난다. 왜? 데몬서버에서 열어보니까 그런건 없어서. 그래서 status(상태값 = -1, -2 이런거)를 싸서
404(에러페이지)를 쏜다(Page Not Found).

한번의 요청과 한번의 응답이 이루어지면 서버와 클라이언트의 연결은 끊어진다. 한번더 요청이 들어오면 새로운 응답을 한다.(이전껀 기억을 못한다)
요청 2 : 메일확인을 위해 로그인을 하면 아이디와 비밀번호 로그인 버튼이 도시락 통에 들어간다. 그럼 데몬서버가 그걸 까본다. 그래서 아이디랑 비번이
있나없나 조회를 한다. 이때 디비를 건드린다.(비지니스 로직) http://www.naver.com/index.html 얘는 프로그램이 아니다. 스크립트 랭귀지 다. 
미리 만들어 놓은 정적인 페이지.

근데 비지니스로직은 프로그램이다. 왜냐면 아이디랑 비번에 어떤값이 들어올지 모르니까..(동적인 문서,ex)대표적인게 java) 데몬이 해결을 못한다. 데몬이 해결할수 있는건 미리 만들어 놓은걸 미리 응답해주는일밖에 못한다.
프로그램을 돌리는건 데몬서버의 역할이 아니라 Container의 역할이다.(Tomcat(WAS,Container)이런 역할을 한다.) 예전에는 지금 우리가 쓰고 있는 Tomcat, Container를 깔고 그다음에 아파치 웹서버를 깔아서 두개를 연동 시킴
지금은 그럴 필요가 없다. Tomcat안에서 데몬이 자체적으로 돈다. 이 안에 비지니스 로직이 있어야 한다(DataBase) 이 안에는 로그인이라는 메서드가 있다 여기서 디비에 연결.
servlet에서 아이디랑 비번을 입력 받는다. 받아서 데이타베이스 생성. 여기서 db.login을 호출 -> database로 호출 -> db로 가서 확인후 있으면 database로 리턴 -> 결과물로 "하바리님 환영합니다" <- 이건 웹브라우저로 출력하는 기술 이건 jsp로 만든다. 
응답하는건 jsp로 받아서 데몬서버로 거쳐 http://www.naver.com/index.html 이쪽으로 응답한다.
database를 모델(M) jsp 를 뷰페이지(v) servelet은 컨트롤러(c)  ---> MVC패턴 MVC가 돌아가는게 was Tomcat 같은 container다.

웹프로그래밍은 무조건 3-tier이다.!!!!
그래서 Middle-tier(Tomcat)을 깐거다.
jsp는 원래 서블릿인데 디자이너들이 편하게 하기 위해 테그기반으로 줄인거임 근데 그걸 서버(왓스)가 인식을 못해 Tomcat이 서블릿servelet으로 바꿔 실행.

초반부에 가장중요한건 Tomcat이다!!(=WAS, container)구동원리를 정확하게 표현 할 수 있어야 함.

4 Tier -> EJB (처음이자 마지막인 강의,,  은행이랑 관공서는 전부다 EJB로 돌리는것 같다.)

4Tier : W/B 기반을 서버로 요청 WAS서버를 가동하면 안에 포트가 여러개 떨어짐.
포트가 아무리 많아도 이안에서 돌아가는건 딱 2개다!
1) webcontainer
2) ejbcontainer
webcontainer 는 webcompanent 데이다 베이스는 웹컨테이너에서 돈다.여기서 디비에 연결 결국엔 데이타 베이스이다.
서블릿은 브라우저의 프론트 jsp는 백 앤드 프론트 w/b랑 연계된다. 이런애들은 WAR(와르)로 폐기
디비랑 연결되는 비지니스 로직(vo...기타 등등) 얘넨 JAR로 폐기
ejbcontainer 는 ejbcompanent 로 돈다.

http://www.naver.com 이걸 하면 war로 그다음 jar로 그다음 db로 db에선 jdbc:Oracle 프로토콜 w/b에서 war는 http 프로토콜 

여기서 질문 3-tier로 해도 되는걸 4-tier로 하는 이유는?
내가 휴가를 받아서 논다. 근데 집에 가만히 있다. 갈데도 없다. 그럼 티비를 튼다. 홈쇼핑을 한다. 근데 이걸 사고 싶다. 그럼 인터넷을 들어가 전화를 한다.080 서비스를 하겟지?
이 사이트에 접속 하는게 웹브라우져만 있는게 아니다. 콜센터도 있다. 콜센터를 쓰는 유저도 엄청 많다. 콜센터도 결국엔 db를 타야하는데 콜센터는 war를 못탄다.
전화를 하면 텔레가 받는다 그럼 텔레가 바로 jar로 정보를 꽂는다 그 사이에서 awt를 짜서 jar로 꽃힌다. 이때 rmil/iiop를 해서 꽂는다. 근데 이게 문제가 많아
다른걸로 돌아선다. (스프링 프레임웍)



-----------------------------------------------------------------------------------------------------------------------------------------------



코딩 시작 >>>>>>>>>>>>>
Context는 프로젝트명이다!
여기서는 서버에서 돌아가기 때문에 메인체크를 안한다.

이 자체로는 서버에서 돌아가는게 아니다 서버에 상속을 받아야 한다.

우리가 만든 클래스가 서버에서 동작할라면 서버에 상속을 받아야 한다.

ServletRequest -> 도시락 싼다 / ServletResponse ->
PrintWriter out = response.getWriter(); -> 웹브라우저로 뿌릴수 있는 기능
"<html><body><h2><b>" ---> html 시작 순서 h2는 글씨 크기를 조금 더 크게 b는 굵게

<?xml version="1.0" encoding="UTF-8"?> ?는 시작과 끝이다.

서블릿이 실행 되는건 <web-app> ....... </web-app> 요기서 

html은 그냥 무조건 외우는 거다 별거 없다. 무조건 외워야함!!! 왜?? 테그기반이여서! html은 메타 렝귀지에 값어치가 없다.



<servlet>
	
	</servlet>				//servlet 1개		//여기서 중요한건 '?????????????(어!?)' 이게 중요!
-----------------------------------------
	<servlet>
	
	</servlet> 
	<servlet>
	
	</servlet> 
						//servlet 2개
-----------------------------------------


<servlet>
		<servlet-name></servlet-name>	// 첫번째자식
		<servlet-class></servlet-class>	// 두번째자식
	</servlet> 


-----------------------------------------

<servlet>
	<servlet-name>GenericTest1</servlet-name>		// GenericTest1 이건 관례이다
	<servlet-class>basic.step1.GenericTest1</servlet-class>
</servlet>   
이게 서버내부에서의 맵핑이다	// 내부에서 맵핑 하나 서버 URL에서 맵핑 하나 총 2개.


URL 앞에는 반드시!! "/" 를 붙힌다!!

<url-pattern>/GT1</url-pattern>  그리고 서버가 잘못되서 다시 구동할때는 서버를 다시 실행해야 한다!


서버가 가동하면서 제일 먼저 가동되는거! web.sml을 읽어들인다.	<web_app>
1. web.xml을 읽어들인다.				          <servlet>
   1) servlet(요청에대한 응답)을 생성				        <servlet_name>
								        <servlet_class>
2. Client가 (servlet)page로 요청을함				   </servlet>
http://localhost:7777/c.p(경로)/GT1				        <servlet_mappint>
-> Server(Container)가 (Servlet)의 Service()를 호출		        <servlet_name>
								        <url_pattern>  GT1   --> http://127.0.0.1:777/web01_Basicservlet/GT1
3. Service(){} 요청을 수행한 후,				   </servlet-mapping>
   다시 Client로 응답을 한다					   </web-app>



-----------------------------------------------------------------------------------------------------------------------------------------------

서버에 돌아가는 프로그램중에 서블릿이라는게 있는데 제너럴 서블릿은 크게 2가지의 부모를 가지고있다.
1) 서블릿, 2) 서블릿 컨피그

GenericServlet 서버사이드에서 만들어주고 요청이들어오면 응답해주고 하는게 servlet에서 한다.
GenericServlet 만의 기능은 로그파일밖에 없다! 나머지는 부모한테 받은거다.
반드시 오버라이딩 해야 하는건 service다. 언제호출? -> 클라이언트가 요청하면 호출
						   -> 누구에 의해? Container에 의해서
						   -> 수행이 다 됬다면? 응답했다는거임



							위에는 javax.servlet
---------------------------------------------------------------------------------
							밑에는 javax.servlet.http


-- Generic의 자식(HttpServlet) --
service
doGet()
doPost()




요청방법 :
1. 소스를 작성한다.
2. 서버를 stop 시킨 후 , 다시 start 한다.
3. 웹 브라우저를 띄워서 주소를 입력한다.
	http://127.0.0.1:7777/web01_BasicServlet/GGG(url mapping)

여기서 2번 3번 한번에 하는거 --> 그냥 실행 하면 한번에 됨.


************   웹프로그래밍에 메카니즘에 대해 이해하자!!   ************

=======================================================================================
위에는 javax.servlet
밑에는 javax.servlet.http
=======================================================================================
..... 위에 대한 2가지에 대한 설명 .....

CGI.(->PHP,ASP,perl(펄),Servlet) -> 서버상에서 돌아가는 프로그램. (정적인 페이지가 아니라 동적인 페이지다.)
servlet 은 CGI다?? -> O.
CGI 자바로만 만들수 있다?? -> X.

< CGI (ASP,PHP) >
w/b 에서 request(요청) -> process만들어짐(요청에 대한 응답하기 위한 메서드가 돈다) -> 요청이 2개 추가되면 process가 2개 더 생성. (요청갯수에 의한 객체갯수 추가) <이리 되면 나중에 메모리가 부족함>
하나의 요청이 하나의 인스턴스! 이게 CGI의 기본적인 메카니즘

< Servlet(JSP) > (=CGI)
웹 브라우저 기반의 클라이언트가 진행.
(요청이 들어오기전에 미리 만들어져 있다. 뭐가? 서블릿이..)
서비스메서드가 호출되면 하나의 쓰레드가 만들어 진다.
요청하나당 하나의 쓰레드가 돈다. (이렇게 됨으로써 메모리의 효율성이 굉장히 좋다.)
얜 서버가 꺼지기 전엔 쓰레드가 안죽는다.


servlet을 만드는 두가지 방법!!		// 1번이던 2번이던 돌아는 간다!(차이점은 패키지가 다르다.)

1) extends GenericServlet	(javax.servlet)		<Protocol 독립적>	--> Http, ftp, telnet에 상관하지 않고 다 돌아간다. (제너릭을 상속받으면 다 된다.)	기본적(통신)인건 되지만 강력한건 안된다.
2) extends HttpServlet		(javax.servlet.http)	<Protocol 종속적>	--> (Http 프로토콜)만!! 된다.


**xml을 가장 잘 알자! xml하나만 알면 서버가 어떻게 되는지 다 알수 있다. xml을 모르면 코더 밖에 안된다! xml을 잘 하자!